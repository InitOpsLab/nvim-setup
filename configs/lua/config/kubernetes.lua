-- ~/.config/nvim/lua/config/kubernetes.lua

-- kubectl.nvim: Cluster interaction (logs, exec, describe, port-forward, etc.)
-- NOTE: kubectl.nvim doesn't have built-in command filtering.
-- To block create/delete commands, we create a wrapper script and prepend it to PATH.

-- Blocked commands (modify this list as needed)
local BLOCKED_COMMANDS = {
	"create",
	"delete",
	-- "apply",  -- uncomment if you want to block apply too
	-- "patch",  -- uncomment if you want to block patch too
	-- "edit",   -- uncomment if you want to block edit too
}

-- Create a wrapper script that filters dangerous commands
local function create_kubectl_wrapper()
	local cache_dir = vim.fn.stdpath("cache")
	local bin_dir = cache_dir .. "/bin"
	local wrapper_path = bin_dir .. "/kubectl"
	
	-- Create bin directory if it doesn't exist
	local ok_mkdir = pcall(vim.fn.mkdir, bin_dir, "p")
	if not ok_mkdir then
		return nil, nil
	end
	
	-- Find the real kubectl (use 'command -v' to find it in PATH)
	local real_kubectl = ""
	local real_kubectl_cmd = "command -v kubectl 2>/dev/null"
	local kubectl_output = vim.fn.system(real_kubectl_cmd)
	local shell_error = vim.v.shell_error
	
	if kubectl_output and shell_error == 0 then
		real_kubectl = kubectl_output:gsub("%s+", ""):gsub("\n", "")
	end
	
	-- If not found, try common locations
	if real_kubectl == "" then
		local common_paths = { "/usr/local/bin/kubectl", "/usr/bin/kubectl", "/opt/homebrew/bin/kubectl" }
		for _, path in ipairs(common_paths) do
			if vim.fn.executable(path) == 1 then
				real_kubectl = path
				break
			end
		end
	end
	
	-- Final fallback
	if real_kubectl == "" then
		real_kubectl = "kubectl" -- fallback to just 'kubectl' and hope it's in PATH
	end
	
	-- Escape the path for shell script
	local escaped_kubectl = real_kubectl:gsub('"', '\\"')
	local blocked_str = table.concat(BLOCKED_COMMANDS, "|")
	
	local wrapper_content = string.format([=[#!/bin/sh
# kubectl wrapper that blocks dangerous commands for kubectl.nvim
# Generated by ~/.config/nvim/lua/config/kubernetes.lua

REAL_KUBECTL="%s"
BLOCKED_COMMANDS="%s"

# Get the command (first argument)
CMD="$1"

# Check if command is blocked
for blocked in $(echo "$BLOCKED_COMMANDS" | tr '|' ' '); do
	if [ "$CMD" = "$blocked" ]; then
		echo "âŒ Error: 'kubectl $CMD' is blocked for safety." >&2
		echo "   Blocked commands: $BLOCKED_COMMANDS" >&2
		echo "   To modify, edit: ~/.config/nvim/lua/config/kubernetes.lua" >&2
		exit 1
	fi
done

# Execute the real kubectl command
exec "$REAL_KUBECTL" "$@"
]=], escaped_kubectl, blocked_str)
	
	-- Write wrapper script
	local file = io.open(wrapper_path, "w")
	if not file then
		return nil, nil
	end
	
	file:write(wrapper_content)
	file:close()
	
	-- Make it executable (ignore errors here)
	pcall(function()
		os.execute("chmod +x " .. vim.fn.shellescape(wrapper_path))
	end)
	
	return bin_dir, wrapper_path
end

-- Setup function for kubectl.nvim
local function setup_kubectl()
	local ok_kubectl, kubectl = pcall(require, "kubectl")
	if not ok_kubectl then
		return
	end
	
	-- Create the wrapper script
	local bin_dir, wrapper_path = create_kubectl_wrapper()
	
	-- Prepend wrapper directory to PATH so it's found before real kubectl
	if bin_dir and wrapper_path then
		-- Prepend to PATH so our wrapper is found first
		local current_path = vim.env.PATH or ""
		vim.env.PATH = bin_dir .. ":" .. current_path
		
		kubectl.setup({
			-- optional:
			-- default_namespace = "default",
			-- prefer_fzf = true,
		})
		
		vim.notify(
			"kubectl.nvim: Command filtering enabled. Blocked: " .. table.concat(BLOCKED_COMMANDS, ", "),
			vim.log.levels.INFO
		)
	else
		-- Fallback: setup without filtering if wrapper creation failed
		kubectl.setup({
			-- optional:
			-- default_namespace = "default",
			-- prefer_fzf = true,
		})
		vim.notify("kubectl.nvim: Warning - Could not create command filter wrapper", vim.log.levels.WARN)
	end
	
	-- Fix: Ensure kubectl always opens in a split with a temporary buffer
	-- This prevents "Buffer is not modifiable" errors and ensures kubectl never overwrites files
	-- kubectl output always goes to a temporary buffer in a split, never to the current file
	
	-- Function to always create a temporary buffer in a split for kubectl operations
	local function ensure_kubectl_buffer()
		-- Always create a new split with a temporary buffer for kubectl output
		-- This ensures we never overwrite the current file
		vim.cmd("split")
		
		-- Create a temporary buffer name
		local tmp_name = "kubectl://" .. os.time() .. "-" .. math.random(1000, 9999)
		vim.api.nvim_buf_set_name(0, tmp_name)
		
		-- Configure as a temporary, modifiable buffer
		vim.bo.modifiable = true
		vim.bo.readonly = false
		vim.bo.buftype = "nofile"  -- Not a real file, won't be saved
		vim.bo.swapfile = false     -- No swap file
		vim.bo.bufhidden = "wipe"   -- Wipe when hidden
		vim.bo.filetype = "yaml"    -- Set filetype for syntax highlighting
		
		return true
	end
	
	-- Hook into kubectl.nvim's buffer operations to always use temporary buffer
	pcall(function()
		local actions = kubectl.actions
		if actions and actions.buffers then
			local buffers = actions.buffers
			
			-- Wrap set_buffer_lines to ensure we're using a temporary buffer
			if buffers.set_buffer_lines then
				local original_set_lines = buffers.set_buffer_lines
				buffers.set_buffer_lines = function(bufnr, start_idx, end_idx, replacement)
					-- Ensure we have a temporary buffer (always create split)
					ensure_kubectl_buffer()
					-- Use the current buffer (the one we just created)
					bufnr = vim.api.nvim_get_current_buf()
					-- Ensure it's modifiable
					pcall(function()
						vim.api.nvim_buf_set_option(bufnr, "modifiable", true)
						vim.api.nvim_buf_set_option(bufnr, "readonly", false)
					end)
					return original_set_lines(bufnr, start_idx, end_idx, replacement)
				end
			end
			
			-- Wrap set_content to always use temporary buffer
			if buffers.set_content then
				local original_set_content = buffers.set_content
				buffers.set_content = function(bufnr, content)
					-- Always create a temporary buffer for kubectl output
					ensure_kubectl_buffer()
					-- Use the current buffer (the one we just created)
					bufnr = vim.api.nvim_get_current_buf()
					-- Ensure it's modifiable
					pcall(function()
						vim.api.nvim_buf_set_option(bufnr, "modifiable", true)
						vim.api.nvim_buf_set_option(bufnr, "readonly", false)
					end)
					return original_set_content(bufnr, content)
				end
			end
		end
		
		-- Hook into the views/display functions to always use temporary buffer
		local views = kubectl.views
		if views then
			-- Wrap displayContentRaw to always create temporary buffer before display
			if views.displayContentRaw then
				local original_display = views.displayContentRaw
				views.displayContentRaw = function(...)
					-- Always create a temporary buffer for kubectl output
					ensure_kubectl_buffer()
					return original_display(...)
				end
			end
		end
	end)
	
	-- Create a pre-command hook to always create temporary buffer before kubectl operations
	vim.api.nvim_create_autocmd("CmdlineEnter", {
		callback = function()
			local cmdline = vim.fn.getcmdline()
			if cmdline:match("^Kubectl") then
				-- Always create a temporary buffer before kubectl operations
				ensure_kubectl_buffer()
			end
		end,
	})
	
	-- Also hook into buffer creation via autocmds
	vim.api.nvim_create_autocmd("FileType", {
		pattern = { "k8s_*" },
		callback = function(event)
			vim.bo[event.buf].modifiable = true
			vim.bo[event.buf].readonly = false
		end,
	})
	
	-- Handle buffer events for kubectl buffers - make them modifiable immediately
	vim.api.nvim_create_autocmd({ "BufEnter", "BufWinEnter", "BufNew", "BufCreate", "BufAdd" }, {
		callback = function(event)
			local bufname = vim.api.nvim_buf_get_name(event.buf)
			local filetype = vim.bo[event.buf].filetype
			-- Check if this is a kubectl buffer (kubectl.nvim uses k8s_* filetypes)
			if bufname:match("kubectl") or filetype:match("k8s_") then
				vim.bo[event.buf].modifiable = true
				vim.bo[event.buf].readonly = false
			end
		end,
	})
	
	-- Additional safeguard: Before any kubectl command, ensure we have a modifiable buffer
	-- This runs before kubectl.nvim tries to write
	vim.api.nvim_create_autocmd("User", {
		pattern = { "Kubectl*" },
		callback = function()
			local current_buf = vim.api.nvim_get_current_buf()
			if not vim.api.nvim_buf_get_option(current_buf, "modifiable") then
				vim.cmd("split")
				vim.bo.modifiable = true
				vim.bo.readonly = false
			end
		end,
	})
end

-- Setup function for kubernetes.nvim
local function setup_kubernetes()
	local ok_kubernetes, kubernetes = pcall(require, "kubernetes")
	if not ok_kubernetes then
		return
	end
	
	kubernetes.setup({
		enable_hover = true,
		enable_schema = true,
	})
end

-- Export setup functions
return {
	setup_kubectl = setup_kubectl,
	setup_kubernetes = setup_kubernetes,
}

